<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="date" content=''>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/../style.css"/>

    <title>writeup</title>

  </head>
  <body>

<ul>
<li><a href="#zadanie-1" id="toc-zadanie-1">Zadanie 1</a></li>
<li><a href="#zadanie-2" id="toc-zadanie-2">Zadanie 2</a>
<ul>
<li><a
href="#następnie-wymień-i-uzasadnij-założenia-jakie-musi-spełniać-rozwiązanie-problemu-sekcji-krytyczne"
id="toc-następnie-wymień-i-uzasadnij-założenia-jakie-musi-spełniać-rozwiązanie-problemu-sekcji-krytyczne">Następnie
wymień i uzasadnij założenia jakie musi spełniać rozwiązanie problemu
sekcji krytyczne</a></li>
<li><a
href="#czemu-w-programach-przestrzeni-użytkownika-do-jej-implementacji-nie-możemy-używać-wyłączania-przerwań-ang.-interrupt-disable"
id="toc-czemu-w-programach-przestrzeni-użytkownika-do-jej-implementacji-nie-możemy-używać-wyłączania-przerwań-ang.-interrupt-disable">Czemu
w programach przestrzeni użytkownika do jej implementacji nie możemy
używać wyłączania przerwań (ang. interrupt disable)?</a></li>
<li><a
href="#odwołując-się-do-prawa-amdahla-powiedz-czemu-programistom-powinno-zależeć-na-tym-by-sekcje-krytyczne-były-możliwie-jak-najkrótsze-określa-się-to-również-mianem-blokowania-drobnoziarnistego-ang.-fine-grained-locking."
id="toc-odwołując-się-do-prawa-amdahla-powiedz-czemu-programistom-powinno-zależeć-na-tym-by-sekcje-krytyczne-były-możliwie-jak-najkrótsze-określa-się-to-również-mianem-blokowania-drobnoziarnistego-ang.-fine-grained-locking.">Odwołując
się do Prawa Amdahla powiedz czemu programistom powinno zależeć na tym,
by sekcje krytyczne były możliwie jak najkrótsze – określa się to
również mianem blokowania drobnoziarnistego (ang. fine-grained
locking).</a></li>
</ul></li>
<li><a href="#zadanie-3" id="toc-zadanie-3">Zadanie 3</a>
<ul>
<li><a
href="#czemu-blokada-wirująca-nie-jest-sprawiedliwa-ang.-fair-3-28.8"
id="toc-czemu-blokada-wirująca-nie-jest-sprawiedliwa-ang.-fair-3-28.8">Czemu
blokada wirująca nie jest sprawiedliwa (ang. fair ) [3 , 28.8]?</a></li>
<li><a
href="#uruchamiamy-n-identycznych-wątków.-kolejno-każdy-z-nich-wchodzi-do-sekcji-krytycznej-po-czym-zostaje-wywłaszczony-przez-jądro.-ile-czasu-zajmie-wszystkim-wątkom-jednokrotne-przejście-przez-sekcję-krytyczną-algorytm-planisty-to-round-robin-kwant-czasu-wynosi-1ms"
id="toc-uruchamiamy-n-identycznych-wątków.-kolejno-każdy-z-nich-wchodzi-do-sekcji-krytycznej-po-czym-zostaje-wywłaszczony-przez-jądro.-ile-czasu-zajmie-wszystkim-wątkom-jednokrotne-przejście-przez-sekcję-krytyczną-algorytm-planisty-to-round-robin-kwant-czasu-wynosi-1ms">Uruchamiamy
n identycznych wątków. Kolejno każdy z nich wchodzi do sekcji
krytycznej, po czym zostaje wywłaszczony przez jądro. Ile czasu zajmie
wszystkim wątkom jednokrotne przejście przez sekcję krytyczną – algorytm
planisty to round-robin, kwant czasu wynosi 1ms</a></li>
</ul></li>
<li><a href="#zadanie-4" id="toc-zadanie-4">Zadanie 4</a>
<ul>
<li><a
href="#czemu-oddanie-czasu-procesora-funkcją-yield-3-28.13-nie-rozwiązuje-wszystkich-problemów-które-mieliśmy-z-blokadami"
id="toc-czemu-oddanie-czasu-procesora-funkcją-yield-3-28.13-nie-rozwiązuje-wszystkich-problemów-które-mieliśmy-z-blokadami">Czemu
oddanie czasu procesora funkcją «yield» [ 3 , 28.13] nie rozwiązuje
wszystkich problemów, które mieliśmy z blokadami</a></li>
<li><a
href="#zreferuj-implementację-podaną-w-3-28.14.-czemu-jest-ona-niepoprawna-bez-użycia-funkcji-setpark"
id="toc-zreferuj-implementację-podaną-w-3-28.14.-czemu-jest-ona-niepoprawna-bez-użycia-funkcji-setpark">Zreferuj
implementację podaną w [ 3, 28.14]. Czemu jest ona niepoprawna bez
użycia funkcji «setpark»?</a></li>
</ul></li>
<li><a href="#zadanie-5" id="toc-zadanie-5">Zadanie 5</a>
<ul>
<li><a
href="#podaj-cztery-warunki-konieczne-do-zaistnienia-zakleszczenia."
id="toc-podaj-cztery-warunki-konieczne-do-zaistnienia-zakleszczenia.">Podaj
cztery warunki konieczne do zaistnienia zakleszczenia.</a></li>
<li><a
href="#na-podstawie-3-32.3-wyjaśnij-w-jaki-sposób-można-przeciwdziałać-zakleszczeniom-ang.-deadlock-prevention"
id="toc-na-podstawie-3-32.3-wyjaśnij-w-jaki-sposób-można-przeciwdziałać-zakleszczeniom-ang.-deadlock-prevention">Na
podstawie [3 , 32.3] wyjaśnij w jaki sposób można przeciwdziałać
zakleszczeniom (ang. deadlock prevention)?</a></li>
<li><a
href="#narzędzie-lockdep-stosowane-w-jądrze-linux-i-mimiker-buduje-graf-skierowany-w-którym-wierzchołkami-są-klasy-blokad.-jak-lockdep-wykrywa-że-może-wystąpić-zakleszczenie-z-jakimi-scenariuszami-sobie-nie-radzi"
id="toc-narzędzie-lockdep-stosowane-w-jądrze-linux-i-mimiker-buduje-graf-skierowany-w-którym-wierzchołkami-są-klasy-blokad.-jak-lockdep-wykrywa-że-może-wystąpić-zakleszczenie-z-jakimi-scenariuszami-sobie-nie-radzi">Narzędzie
lockdep, stosowane w jądrze Linux i Mimiker, buduje graf skierowany, w
którym wierzchołkami są klasy blokad. Jak lockdep wykrywa, że może
wystąpić zakleszczenie? Z jakimi scenariuszami sobie nie radzi?</a></li>
</ul></li>
<li><a href="#zadanie-6" id="toc-zadanie-6">Zadanie 6</a></li>
<li><a href="#zadanie-7" id="toc-zadanie-7">Zadanie 7</a></li>
<li><a href="#zadanie-8" id="toc-zadanie-8">Zadanie 8</a></li>
<li><a href="#zadanie-9" id="toc-zadanie-9">Zadanie 9</a></li>
</ul>
<h2 id="zadanie-1">Zadanie 1</h2>
<div class="highlight"><pre><span></span>Zadanie 1. Zapoznaj się z poniższym programem. Rozważamy wartości przechowywane w zmiennych:
«myid», «strtab», «vargp», «cnt», «argc» i «argv[0]». Określ czy są one współdzielone i które z nich
będą źródłem wyścigów (ang. data race).
1 __thread long myid;
2 static char **strtab;
3
4 void *thread(void *vargp) {
5 myid = *(long *)vargp;
6 static int cnt = 0;
7 printf(&quot;[%ld]: %s (cnt=%d)\n&quot;, myid, strtab[myid], ++cnt);
8 return NULL;
9 }
10
11 int main(int argc, char *argv[]) {
12 ...
13 strtab = argv;
14 while (argc &gt; 0) {
15 myid = --argc;
16 pthread_create(&amp;tid, NULL, thread, (void *)&amp;myid);
17 }
18 ...
19 }
</pre></div>

<p>myid - zmienna globalna, nie współdzielona<br />
strtab - zmienna globalna, wspoldzielona, nie jest źródłem wyścigu, bo
tylko czytana<br />
vargp - zmienna lokalna, niewspoldzielona, dane na które wskazuje też są
niewspółdzielone<br />
cnt - zmienna globalna, współdzielona, wyścig (linijka 7, nie ma
kontroli dostępu)<br />
argc - zmienna lokalna, niewspółdzielone, używana tylko w main<br />
argv[0] - jest używane przez strtab, więc współdzielone, ale nie jest
źródłem wyścigu, bo jest jedynie czytane</p>
<h2 id="zadanie-2">Zadanie 2</h2>
<div class="highlight"><pre><span></span>Zadanie 2. Podaj definicję sekcji krytycznej [ 2 , 6.2]. Następnie wymień i uzasadnij założenia jakie musi
spełniać rozwiązanie problemu sekcji krytycznej. Czemu w programach przestrzeni użytkownika do jej
implementacji nie możemy używać wyłączania przerwań (ang. interrupt disable)? Odwołując się do Prawa
Amdahla powiedz czemu programistom powinno zależeć na tym, by sekcje krytyczne były możliwie jak
najkrótsze – określa się to również mianem blokowania drobnoziarnistego (ang. fine-grained locking).
</pre></div>

<h3
id="następnie-wymień-i-uzasadnij-założenia-jakie-musi-spełniać-rozwiązanie-problemu-sekcji-krytyczne">Następnie
wymień i uzasadnij założenia jakie musi spełniać rozwiązanie problemu
sekcji krytyczne</h3>
<ol type="1">
<li>wzajemne wykluczenie - tylko jeden proces moze wykonywac dana sekcje
krytyczna</li>
<li>postep - jeśli żaden proces nie wykonuje sekcji krytycznej, a
niektóre procesy chcą do niej wejść, to tylko te procesy które nie
wykonują “remainder section” decydują kto wejdzie do sekcji krytycznej,
a podjęcie tej decyzji nie może trwać w nieskończoność</li>
<li>granica czasu oczekiwania - istnieje limit ile razy inne procesy
mogą wejść do sekcji krytycznej, po tym jak wysłaliśmy request żeby
wejść do sekcji</li>
</ol>
<h3
id="czemu-w-programach-przestrzeni-użytkownika-do-jej-implementacji-nie-możemy-używać-wyłączania-przerwań-ang.-interrupt-disable">Czemu
w programach przestrzeni użytkownika do jej implementacji nie możemy
używać wyłączania przerwań (ang. interrupt disable)?</h3>
<p>możemy w środowisku jednoprocesorowym, w wieloprocesorowym jest
opóźnienie w tym jak prędko inne procesory dostaną request o
zatrzymanie, więc nie zadziała.</p>
<div class="highlight"><pre><span></span>Unfortunately, this solution is not as feasible in a multiprocessor environ-
ment. Disabling interrupts on a multiprocessor can be time consuming, since
the message is passed to all the processors. This message passing delays entry
into each critical section, and system efficiency decreases. Also consider the
effect on a system’s clock if the clock is kept updated by interrupts.
</pre></div>

<h3
id="odwołując-się-do-prawa-amdahla-powiedz-czemu-programistom-powinno-zależeć-na-tym-by-sekcje-krytyczne-były-możliwie-jak-najkrótsze-określa-się-to-również-mianem-blokowania-drobnoziarnistego-ang.-fine-grained-locking.">Odwołując
się do Prawa Amdahla powiedz czemu programistom powinno zależeć na tym,
by sekcje krytyczne były możliwie jak najkrótsze – określa się to
również mianem blokowania drobnoziarnistego (ang. fine-grained
locking).</h3>
<p>Sekcja krytyczna, to kod którego nie da się zrównoleglić, a chcemy
móc zrównoleglić jak najwięcej kodu.</p>
<h2 id="zadanie-3">Zadanie 3</h2>
<div class="highlight"><pre><span></span>Zadanie 3. Podaj w pseudokodzie semantykę instrukcji atomowej compare-and-swap i przy jej pomocy
zaimplementuj blokadę wirującą (ang. spin lock) [3 , 28.7]. Niech typ «spin_t» będzie równoważny «int».
Podaj ciało procedur «void lock(spin_t *)» i «void unlock(spin_t *)».  
Czemu blokada wirująca nie jest sprawiedliwa (ang. fair ) [3 , 28.8]? 
Uruchamiamy n identycznych wątków. Kolejno każdy z nich wchodzi do sekcji krytycznej, po czym zostaje wywłaszczony przez jądro. Ile czasu zajmie wszystkim wątkom jednokrotne przejście przez sekcję krytyczną – algorytm planisty to round-robin, kwant czasu wynosi 1ms
</pre></div>

<div id="cb5" class="sourceCode">
<div class="highlight"><pre><span></span><span class="n">spin_t</span><span class="w"> </span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="n">spin_t</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">spin_t</span><span class="w"> </span><span class="n">expected</span><span class="p">,</span><span class="w"> </span><span class="n">spin_t</span><span class="w"> </span><span class="n">new</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">spin_t</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">original</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">expected</span><span class="p">)</span>
<span class="w">      </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">original</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">spin_t</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">lock</span><span class="p">(</span><span class="n">spin_t</span><span class="w"> </span><span class="o">*</span><span class="n">spin</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">CompareAndSwap</span><span class="p">(</span><span class="n">spin</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// spin</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">unlock</span><span class="p">(</span><span class="n">spin_t</span><span class="w"> </span><span class="o">*</span><span class="n">spin</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">spin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</div>
<h3
id="czemu-blokada-wirująca-nie-jest-sprawiedliwa-ang.-fair-3-28.8">Czemu
blokada wirująca nie jest sprawiedliwa (ang. fair ) [3 , 28.8]?</h3>
<p>Nie możęmy zapewnić, że wątek czekający na wejscie do sekcji
krytycznej kiedykolwiek do niej wejdzie, zależy to od schedulera,
któremu kolejnemu wątkowi da wejść do sekcji krytycznej, po tym jak
poprzedni wątek z niej wyszedł</p>
<h3
id="uruchamiamy-n-identycznych-wątków.-kolejno-każdy-z-nich-wchodzi-do-sekcji-krytycznej-po-czym-zostaje-wywłaszczony-przez-jądro.-ile-czasu-zajmie-wszystkim-wątkom-jednokrotne-przejście-przez-sekcję-krytyczną-algorytm-planisty-to-round-robin-kwant-czasu-wynosi-1ms">Uruchamiamy
n identycznych wątków. Kolejno każdy z nich wchodzi do sekcji
krytycznej, po czym zostaje wywłaszczony przez jądro. Ile czasu zajmie
wszystkim wątkom jednokrotne przejście przez sekcję krytyczną – algorytm
planisty to round-robin, kwant czasu wynosi 1ms</h3>
<ol type="1">
<li>wątek wykonuje sekcje krytyczną przez 1ms</li>
<li>wątek dostaje przerwanie</li>
<li>scheduling przechodzi cyklicznie przez całą reszte wątków które nic
nie robią</li>
<li>wątek znów wykonuje sekcje krytyczną przez 1ms</li>
</ol>
<p>załóżmy że czas wykonania sekcji krytycznej to jakieś k (w
milisekundach)<br />
wtedy więc musimy wykonywac wątki przez k * n (milisekund), aby przejść
przez jedną sekcję krytyczną.<br />
Aby przejść przez wszystkie sekcje krytyczne raz mamy więc k * n * n
(milisekund)</p>
<h2 id="zadanie-4">Zadanie 4</h2>
<div class="highlight"><pre><span></span>Zadanie 4. Wiemy, że aktywne czekanie (ang. busy waiting) nie jest właściwym sposobem oczekiwania
na zwolnienie blokady. Powstaje zatem potrzeba stworzenia blokady usypiającej.  
Czemu oddanie czasu procesora funkcją «yield» [ 3 , 28.13] nie rozwiązuje wszystkich problemów, które mieliśmy z blokadami
wirującymi? 
Zreferuj implementację podaną w [ 3, 28.14]. Czemu jest ona niepoprawna bez użycia funkcji «setpark»?
</pre></div>

<h3
id="czemu-oddanie-czasu-procesora-funkcją-yield-3-28.13-nie-rozwiązuje-wszystkich-problemów-które-mieliśmy-z-blokadami">Czemu
oddanie czasu procesora funkcją «yield» [ 3 , 28.13] nie rozwiązuje
wszystkich problemów, które mieliśmy z blokadami</h3>
<p>Nadal jesteśmy skazani na implementacje schedulera, który może nam
zagłodzić któryś wątek oraz nadal musimy przejść przez wszystkie
wątki</p>
<h3
id="zreferuj-implementację-podaną-w-3-28.14.-czemu-jest-ona-niepoprawna-bez-użycia-funkcji-setpark">Zreferuj
implementację podaną w [ 3, 28.14]. Czemu jest ona niepoprawna bez
użycia funkcji «setpark»?</h3>
<p>ponieważ jeśli wątek zostanie wywłaszczony tuż przed wywołaniem
park(), a w tym czasie wątek trzymający blokade się zwolni to uśpiony
wątek będzie spał w nieskończoność (bo nie ma kto go obudzić), jest to
wakeup/waiting race.<br />
Gdy użyjemy wcześniej setpark(), to jeśli nastąpi opisana wyżej
sytuacja, to park() po prostu od razu powróci zamiast spac.</p>
<h2 id="zadanie-5">Zadanie 5</h2>
<div class="highlight"><pre><span></span>Zadanie 5. Podaj cztery warunki konieczne do zaistnienia zakleszczenia.  
Na podstawie [3 , 32.3] wyjaśnij w jaki sposób można przeciwdziałać zakleszczeniom (ang. deadlock prevention)?  
Narzędzie lockdep, stosowane w jądrze Linux i Mimiker, buduje graf skierowany, w którym wierzchołkami są klasy blokad.  
Jak lockdep wykrywa, że może wystąpić zakleszczenie? Z jakimi scenariuszami sobie nie radzi?
</pre></div>

<h3
id="podaj-cztery-warunki-konieczne-do-zaistnienia-zakleszczenia.">Podaj
cztery warunki konieczne do zaistnienia zakleszczenia.</h3>
<div class="highlight"><pre><span></span>• Mutual exclusion: Threads claim exclusive control of resources that
they require (e.g., a thread grabs a lock).
• Hold-and-wait: Threads hold resources allocated to them (e.g., locks
that they have already acquired) while waiting for additional re-
sources (e.g., locks that they wish to acquire).
• No preemption: Resources (e.g., locks) cannot be forcibly removed
from threads that are holding them.
• Circular wait: There exists a circular chain of threads such that each
thread holds one or more resources (e.g., locks) that are being re-
quested by the next thread in the chain
</pre></div>

<h3
id="na-podstawie-3-32.3-wyjaśnij-w-jaki-sposób-można-przeciwdziałać-zakleszczeniom-ang.-deadlock-prevention">Na
podstawie [3 , 32.3] wyjaśnij w jaki sposób można przeciwdziałać
zakleszczeniom (ang. deadlock prevention)?</h3>
<p>Zapobiec któremukolwiek z warunków.<br />
Żeby zapobiec <strong>circular wait</strong> wystarczy, że zawsze
będziemy pobierać blokady (acquire locks) w tej samej kolejności.<br />
Czyli nasz wadliwy kod:</p>
<div id="cb9" class="sourceCode">
<div class="highlight"><pre><span></span><span class="n">Thread</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
</pre></div>

</div>
<p>zamienimy na:</p>
<div id="cb10" class="sourceCode">
<div class="highlight"><pre><span></span><span class="n">Thread</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span>
</pre></div>

</div>
<p><strong>Hold-and-wait</strong> wystarczy pobrać wszystkie blokady na
raz:</p>
<div id="cb11" class="sourceCode">
<div class="highlight"><pre><span></span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">prevention</span><span class="p">);</span><span class="w"> </span><span class="c1">// begin acquisition</span>
<span class="mi">2</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
<span class="mi">3</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L2</span><span class="p">);</span>
<span class="mi">4</span><span class="w"> </span><span class="p">...</span>
<span class="mi">5</span><span class="w"> </span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">prevention</span><span class="p">);</span><span class="w"> </span><span class="c1">// end</span>
</pre></div>

</div>
<p>Minusy to zmniejszenie współbieżności, bo pobieramy od razu locki a
nie gdy są potrzebne</p>
<p><strong>No preemption</strong></p>
<div id="cb12" class="sourceCode">
<div class="highlight"><pre><span></span><span class="mi">1</span><span class="w"> </span><span class="n">top</span><span class="o">:</span>
<span class="mi">2</span><span class="w"> </span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
<span class="mi">3</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pthread_mutex_trylock</span><span class="p">(</span><span class="n">L2</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="mi">4</span><span class="w"> </span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">L1</span><span class="p">);</span>
<span class="mi">5</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="mi">6</span><span class="w"> </span><span class="p">}</span>
</pre></div>

</div>
<p>w tej metodzie nie blokujemy w kółko tylko próbujemy pobrać mutex,
jak sie nie udało to zwalniamy poprzednio pobrane mutexy, więc któryś z
wątków wreszcie zrobi progress.<br />
Istnieje jednak szansa, że oba wątki będą wykonywać się dosłownie
równolegle i wzajemne blokowanie wystąpi za każdym razem, nazywamy to
livelockiem.<br />
Żeby obejść ten problem można dodać np. małe losowe opoznienie do wątku,
aby za którymś razem się udało.</p>
<p><strong>Mutual Exclusion</strong> Propozycja jest taka by w ogóle nie
używać locków, tylko samych instrukcji atomowych, co wymaga silnego
wsparcia hardware’owego. np.:</p>
<div class="highlight"><pre><span></span>1 int CompareAndSwap(int *address, int expected, int new) {
2   if (*address == expected) {
3       *address = new;
4       return 1; // success
5   }
6   return 0; // failure
7 }
1 void AtomicIncrement(int *value, int amount) {
2   do {
3       int old = *value;
4   } while (CompareAndSwap(value, old, old + amount) == 0);
5 }
</pre></div>

<p>Próbujemy wbić się w moment, gdy żaden inny wątek w międzyczasie nie
podmienił nam wartośći.</p>
<p><strong>Deadlock Avoidance via Scheduling</strong> Autor jako
rozwiązanie uniknięcia zakleszczenia podaje mądre planowanie, które wie
jakie procesory powinny wykonywać jakie wątki, tak aby nie doszło do
deadlocka. <img src="" alt="./assets/deadlock_scheduling.png" /></p>
<h3
id="narzędzie-lockdep-stosowane-w-jądrze-linux-i-mimiker-buduje-graf-skierowany-w-którym-wierzchołkami-są-klasy-blokad.-jak-lockdep-wykrywa-że-może-wystąpić-zakleszczenie-z-jakimi-scenariuszami-sobie-nie-radzi">Narzędzie
lockdep, stosowane w jądrze Linux i Mimiker, buduje graf skierowany, w
którym wierzchołkami są klasy blokad. Jak lockdep wykrywa, że może
wystąpić zakleszczenie? Z jakimi scenariuszami sobie nie radzi?</h3>
<p>Dla każdej klasy blokady L lockdep posiada dwie listy.<br />
before list: lista blokad przejmowanych przed L<br />
after list: lista blokad przejmowanych w czasie gdy L jest przejęte</p>
<p>Gdy wątek chce przejąć blokade L, to lockdep sprawdza czy któraś z
blokad przyjętych przez wątek jest na after list, jeśli tak to została
naruszona kolejność i potencjalnie może nastąpić deadlock.<br />
Z tego co rozumiem idea jest taka, że jeśli za jednym razem w czasie gdy
blokada L była przejęta, została przejęta jakaś blokada L2, to nie
powinna wystąpić sytuacja, że kolejnym razem gdy przejmujemy L, to L2
już jest przejęte.</p>
<p>Ponieważ lockdep korzysta z klas blokad, to nie bierze od uwage
sytuacji gdy ten sam obiekt może mieć różne locking rules i podaje taki
przykład:</p>
<div id="cb14" class="sourceCode">
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">node_data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">mutex_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">tree_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">node_data</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="n">mutex_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">lock_tree_node_and_storage</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">tree_node</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_root</span><span class="p">(</span><span class="n">A</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="n">A</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>

</div>
<h2 id="zadanie-6">Zadanie 6</h2>
<div class="highlight"><pre><span></span>Zadanie 6. Poniżej znajduje się propozycja2 programowego rozwiązania problemu wzajemnego wykluczania
(ang. mutual exclusion) dla dwóch procesów. Znajdź kontrprzykład, w którym to rozwiązanie zawodzi.
1 shared boolean blocked [2] = { false, false };
2 shared int turn = 0;
3
4 void P (int id) {
5   while (true) {
6       blocked[id] = true;
7       while (turn != id) {
8           while (blocked[1 - id])
9               continue;
10          turn = id;
11      }
12 /* put code to execute in critical section here */
13      blocked[id] = false;
14  }
15 }
16
17 void main() { parbegin (P(0), P(1)); }
</pre></div>

<p>Pierwszy wykonuje się turn = 0, no chyba że wcześniej id = 1. Co
jeśli najpierw wykona się id = 1 aż do linii 10, a potem wywłaszczy się
id = 0, który dojdzie do sekcji krytycznej?<br />
Po wznowieniu id = 1 też dojdzie do sekcji krytycznej, więc oba wątki
się w nim znajdą.</p>
<h2 id="zadanie-7">Zadanie 7</h2>
<div class="highlight"><pre><span></span>Zadanie 7. Algorytm Petersona3 rozwiązuje programowo problem wzajemnego wykluczania. Zreferuj poniższą
wersję implementacji tego algorytmu dla dwóch procesów. Uzasadnij jego poprawność.
1 shared boolean blocked [2] = { false, false };
2 shared int turn = 0;
3
4 void P (int id) {
5   while (true) {
6       blocked[id] = true;
7       turn = 1 - id;
8       while (blocked[1 - id] &amp;&amp; turn == (1 - id))
9           continue;
10      /* put code to execute in critical section here */
11      blocked[id] = false;
12  }
13 }
14
15 void main() { parbegin (P(0), P(1)); }
</pre></div>

<p>Jeśli oba procesy chcą wejść do sekcji krytycznej, to wejdzie ten
którego jest kolej (turn).<br />
Jeśli jeden proces chce wejść, to zrobi to ponieważ drugi nie jest
blocked.<br />
Mamy więc i mutual exclusion i postęp</p>
<h2 id="zadanie-8">Zadanie 8</h2>
<div class="highlight"><pre><span></span>Zadanie 8. Poniżej podano błędną implementację semafora zliczającego przy pomocy semaforów binar-
nych. Wartość «count» może być ujemna – wartość bezwzględna oznacza wtedy liczbę uśpionych procesów.
Znajdź kontrprzykład i zaprezentuj wszystkie warunki niezbędne do jego odtworzenia.
</pre></div>

<p>Binary semaphore: semaphore whose value is always 0 or 1 no więc
delay nie bardzo może być semaforem binarnym. Co jeśli przyjdą po sobie
dwaj konsumenci i wywołają P? Oba będą czekać w [ while (s == 0) wait();
s–; ]. Jeśli więc przyjdzie producent i coś wyprodukuje, to jeden z
wątków uśpionych który</p>
<h2 id="zadanie-9">Zadanie 9</h2>
<p>A checks condition, it’s not satisfied B satisfies condition, wake A
up A goes to sleep/blocks</p>
  </body>
</html>
