<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="date" content=''>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/../style.css"/>

    <title>writeup</title>

  </head>
  <body>

<ul>
<li><a href="#zadanie-1" id="toc-zadanie-1">Zadanie 1</a>
<ul>
<li><a
href="#co-robi-operacja-read2-i-write2-jeśli-bufor-rury-jest-odpowiednio-pusty-albo-pełny"
id="toc-co-robi-operacja-read2-i-write2-jeśli-bufor-rury-jest-odpowiednio-pusty-albo-pełny">Co
robi operacja read(2) i write(2), jeśli bufor rury jest odpowiednio
pusty albo pełny?</a></li>
<li><a
href="#jakie-gwarancje-daje-nam-operacja-write-na-rurze-do-której-pisze-wiele-procesów-każdy-z-nich-wiersze-tekstu-nie-dłuższe-niż-pipe_buf"
id="toc-jakie-gwarancje-daje-nam-operacja-write-na-rurze-do-której-pisze-wiele-procesów-każdy-z-nich-wiersze-tekstu-nie-dłuższe-niż-pipe_buf">Jakie
gwarancje daje nam operacja write na rurze, do której pisze wiele
procesów – każdy z nich wiersze tekstu nie dłuższe niż
«PIPE_BUF»?</a></li>
<li><a
href="#weźmy-potok-utworzony-poleceniem-ps--ef-grep-sh-wc--l.-czemu-wszystkie-procesy-należące-do-potoku-zakończą-się-bez-interwencji-powłoki-jeśli-co-najmniej-jeden-z-nich-umrze"
id="toc-weźmy-potok-utworzony-poleceniem-ps--ef-grep-sh-wc--l.-czemu-wszystkie-procesy-należące-do-potoku-zakończą-się-bez-interwencji-powłoki-jeśli-co-najmniej-jeden-z-nich-umrze">Weźmy
potok utworzony poleceniem «ps -ef | grep sh | wc -l». Czemu wszystkie
procesy należące do potoku zakończą się bez interwencji powłoki, jeśli
co najmniej jeden z nich umrze?</a></li>
<li><a href="#kiedy-operacje-read-i-write-na-rurze-zwracają-short-count"
id="toc-kiedy-operacje-read-i-write-na-rurze-zwracają-short-count">Kiedy
operacje read i write na rurze zwracają „short count”?</a></li>
<li><a
href="#jak-można-połączyć-rodzica-i-dziecko-rurą-która-została-utworzona-po-uruchomieniu-dziecka"
id="toc-jak-można-połączyć-rodzica-i-dziecko-rurą-która-została-utworzona-po-uruchomieniu-dziecka">Jak
można połączyć rodzica i dziecko rurą, która została utworzona po
uruchomieniu dziecka?</a></li>
</ul></li>
<li><a href="#zadanie-2" id="toc-zadanie-2">Zadanie 2</a>
<ul>
<li><a
href="#do-czego-służy-wywołanie-systemowe-ioctl2-zauważ-że-stosowane-jest-głównie-do-plików-urządzeń-znakowych-lub-blokowych."
id="toc-do-czego-służy-wywołanie-systemowe-ioctl2-zauważ-że-stosowane-jest-głównie-do-plików-urządzeń-znakowych-lub-blokowych.">Do
czego służy wywołanie systemowe ioctl(2)? Zauważ, że stosowane jest
głównie do plików urządzeń znakowych lub blokowych.</a></li>
<li><a
href="#na-podstawie-pliku-ioccom.h2-wyjaśnij-znaczenie-drugiego-i-trzeciego-parametru-wywołania-ioctl."
id="toc-na-podstawie-pliku-ioccom.h2-wyjaśnij-znaczenie-drugiego-i-trzeciego-parametru-wywołania-ioctl.">Na
podstawie pliku ioccom.h2 wyjaśnij znaczenie drugiego i trzeciego
parametru wywołania ioctl.</a></li>
<li><a
href="#używając-przeglądarki-kodu3-jądra-netbsd-znajdź-definicje-operacji-dioceject-kioctype-i-siocgifconf-a-następnie-wytłumacz-co-one-robią."
id="toc-używając-przeglądarki-kodu3-jądra-netbsd-znajdź-definicje-operacji-dioceject-kioctype-i-siocgifconf-a-następnie-wytłumacz-co-one-robią.">Używając
przeglądarki kodu3 jądra NetBSD znajdź definicje operacji «DIOCEJECT»,
«KIOCTYPE» i «SIOCGIFCONF», a następnie wytłumacz co one robią.</a></li>
</ul></li>
<li><a href="#zadanie-3" id="toc-zadanie-3">Zadanie 3</a>
<ul>
<li><a
href="#na-podstawie-3-rysunek-10-32-przedstaw-reprezentację-katalogu-a-następnie-wyjaśnij-jak-przebiegają-operacje-usuwania-i-dodawania-pliku."
id="toc-na-podstawie-3-rysunek-10-32-przedstaw-reprezentację-katalogu-a-następnie-wyjaśnij-jak-przebiegają-operacje-usuwania-i-dodawania-pliku.">Na
podstawie [3, rysunek 10-32] przedstaw reprezentację katalogu, a
następnie wyjaśnij jak przebiegają operacje usuwania i dodawania
pliku.</a></li>
<li><a
href="#w-pierwszym-przypadku-rozważ-scenariusz-w-którym-w-reprezentacji-katalogu-za-lub-przed-usuwanym-wpisem-istnieją-nieużytki"
id="toc-w-pierwszym-przypadku-rozważ-scenariusz-w-którym-w-reprezentacji-katalogu-za-lub-przed-usuwanym-wpisem-istnieją-nieużytki">W
pierwszym przypadku rozważ scenariusz, w którym w reprezentacji katalogu
za lub przed usuwanym wpisem istnieją nieużytki</a></li>
<li><a
href="#w-drugim-kiedy-w-pliku-katalogu-nie-udaje-się-znaleźć-wystarczająco-dużo-miejsca-na-przechowanie-wpisu."
id="toc-w-drugim-kiedy-w-pliku-katalogu-nie-udaje-się-znaleźć-wystarczająco-dużo-miejsca-na-przechowanie-wpisu.">W
drugim, kiedy w pliku katalogu nie udaje się znaleźć wystarczająco dużo
miejsca na przechowanie wpisu.</a></li>
<li><a
href="#jądro-leniwie-wykonuje-operację-kompaktowania-na-katalogach-kiedy-opłaca-się-ją-zrobić"
id="toc-jądro-leniwie-wykonuje-operację-kompaktowania-na-katalogach-kiedy-opłaca-się-ją-zrobić">Jądro
leniwie wykonuje operację kompaktowania na katalogach – kiedy opłaca się
ją zrobić?</a></li>
</ul></li>
<li><a href="#zadanie-4" id="toc-zadanie-4">Zadanie 4</a>
<ul>
<li><a href="#od-jakiego-numeru-i-węzła-algorytm-zaczyna-działanie"
id="toc-od-jakiego-numeru-i-węzła-algorytm-zaczyna-działanie">Od jakiego
numeru i-węzła algorytm zaczyna działanie?</a></li>
<li><a
href="#skąd-sterownik-uniksowego-systemu-plików-wie-gdzie-na-dysku-znajduje-się-i-ty-bajt-pliku"
id="toc-skąd-sterownik-uniksowego-systemu-plików-wie-gdzie-na-dysku-znajduje-się-i-ty-bajt-pliku">Skąd
sterownik uniksowego systemu plików wie gdzie na dysku znajduje się i-ty
bajt pliku?</a></li>
<li><a
href="#próba-utworzenia-dowiązania-do-pliku-procversion-kończy-się-błędem-exdev.-czemu-nie-możemy-tworzyć-dowiązań-do-plików-znajdujących-się-w-obrębie-innych-zamontowanych-systemów-plików"
id="toc-próba-utworzenia-dowiązania-do-pliku-procversion-kończy-się-błędem-exdev.-czemu-nie-możemy-tworzyć-dowiązań-do-plików-znajdujących-się-w-obrębie-innych-zamontowanych-systemów-plików">Próba
utworzenia dowiązania do pliku «/proc/version» kończy się błędem
«EXDEV». Czemu nie możemy tworzyć dowiązań do plików znajdujących się w
obrębie innych zamontowanych systemów plików?</a></li>
</ul></li>
<li><a href="#zadanie-5" id="toc-zadanie-5">Zadanie 5</a></li>
<li><a href="#zadanie-6" id="toc-zadanie-6">Zadanie 6</a></li>
</ul>
<h2 id="zadanie-1">Zadanie 1</h2>
<div class="highlight"><pre><span></span>Zadanie 1. Rura pipe(7) to jednokierunkowe narzędzie do komunikacji międzyprocesowej.  
Co robi operacja read(2) i write(2), jeśli bufor rury jest odpowiednio pusty albo pełny?   
Jakie gwarancje daje nam operacja write na rurze, do której pisze wiele procesów – każdy z nich wiersze tekstu nie dłuższe niż «PIPE_BUF»?  
Weźmy potok utworzony poleceniem «ps -ef | grep sh | wc -l». 
Czemu wszystkie procesy należące do potoku zakończą się bez interwencji powłoki, jeśli co najmniej jeden z nich umrze?  
Kiedy operacje read i write na rurze zwracają „short count”?  
Jak można połączyć rodzica i dziecko rurą, która została utworzonapo uruchomieniu dziecka?
</pre></div>

<h3
id="co-robi-operacja-read2-i-write2-jeśli-bufor-rury-jest-odpowiednio-pusty-albo-pełny">Co
robi operacja read(2) i write(2), jeśli bufor rury jest odpowiednio
pusty albo pełny?</h3>
<p>pipe(7)</p>
<div class="highlight"><pre><span></span>       If a process attempts to read from an empty pipe, then read(2)
       will block until data is available.  If a process attempts to
       write to a full pipe (see below), then write(2) blocks until
       sufficient data has been read from the pipe to allow the write to
       complete.


       Nonblocking I/O is possible by using the fcntl(2) F_SETFL
       operation to enable the O_NONBLOCK open file status flag or by
       opening a fifo(7) with O_NONBLOCK.  If any process has the pipe
       open for writing, reads fail with EAGAIN; otherwise—with no
       potential writers—reads succeed and return empty.
</pre></div>

<h3
id="jakie-gwarancje-daje-nam-operacja-write-na-rurze-do-której-pisze-wiele-procesów-każdy-z-nich-wiersze-tekstu-nie-dłuższe-niż-pipe_buf">Jakie
gwarancje daje nam operacja write na rurze, do której pisze wiele
procesów – każdy z nich wiersze tekstu nie dłuższe niż «PIPE_BUF»?</h3>
<p>APUE p.537</p>
<div class="highlight"><pre><span></span>When we’re writing to a pipe (or FIFO), the constant PIPE_BUF specifies the
kernel’s pipe buffer size. A write of PIPE_BUF bytes or less will not be interleaved
with the writes from other processes to the same pipe (or FIFO). But if multiple
processes are writing to a pipe (or FIFO), and if we write more than PIPE_BUF bytes,
the data might be interleaved with the data from the other writers. We can determine
the value of PIPE_BUF by using pathconf or fpathconf (recall Figure 2.12).
</pre></div>

<h3
id="weźmy-potok-utworzony-poleceniem-ps--ef-grep-sh-wc--l.-czemu-wszystkie-procesy-należące-do-potoku-zakończą-się-bez-interwencji-powłoki-jeśli-co-najmniej-jeden-z-nich-umrze">Weźmy
potok utworzony poleceniem «ps -ef | grep sh | wc -l». Czemu wszystkie
procesy należące do potoku zakończą się bez interwencji powłoki, jeśli
co najmniej jeden z nich umrze?</h3>
<p>tl;dr Jeśli write-end rury został zamknięty, to read() zwróci EOF, co
zakończy proces czytający.<br />
Jeśli read-end rury został zamknięty, to write() spowoduje wygenerowanie
sygnału SIGPIPE.<br />
W ten sposób indukcyjnie zamkną się wszystkie procesy.</p>
<p>pipe(7)</p>
<div class="highlight"><pre><span></span>       If all file descriptors referring to the write end of a pipe have
       been closed, then an attempt to read(2) from the pipe will see
       end-of-file (read(2) will return 0).  If all file descriptors
       referring to the read end of a pipe have been closed, then a
       write(2) will cause a SIGPIPE signal to be generated for the
       calling process.  If the calling process is ignoring this signal,
       then write(2) fails with the error EPIPE.  An application that
       uses pipe(2) and fork(2) should use suitable close(2) calls to
       close unnecessary duplicate file descriptors; this ensures that
       end-of-file and SIGPIPE/EPIPE are delivered when appropriate.
</pre></div>

<h3 id="kiedy-operacje-read-i-write-na-rurze-zwracają-short-count">Kiedy
operacje read i write na rurze zwracają „short count”?</h3>
<div class="highlight"><pre><span></span>O_NONBLOCK enabled, n &lt;= PIPE_BUF
      If there is room to write n bytes to the pipe, then
      write(2) succeeds immediately, writing all n bytes;
      otherwise write(2) fails, with errno set to EAGAIN.


O_NONBLOCK enabled, n &gt; PIPE_BUF
      If the pipe is full, then write(2) fails, with errno set
      to EAGAIN.  Otherwise, from 1 to n bytes may be written
      (i.e., a &quot;partial write&quot; may occur; the caller should
      check the return value from write(2) to see how many bytes
      were actually written), and these bytes may be interleaved
      with writes by other processes.
</pre></div>

<p>A tak to z grubsza po otrzymaniu EOF</p>
<h3
id="jak-można-połączyć-rodzica-i-dziecko-rurą-która-została-utworzona-po-uruchomieniu-dziecka">Jak
można połączyć rodzica i dziecko rurą, która została utworzona po
uruchomieniu dziecka?</h3>
<p>Można użyć named pipe (FIFO).</p>
<h2 id="zadanie-2">Zadanie 2</h2>
<div class="highlight"><pre><span></span>Zadanie 2. Zapoznaj się z krytyką interfejsu plików przedstawioną w podrozdziale „ioctl and fcntl Are an Embarrassment”1.  
Do czego służy wywołanie systemowe ioctl(2)? Zauważ, że stosowane jest głównie do plików urządzeń znakowych lub blokowych.  
Na podstawie pliku ioccom.h2 wyjaśnij znaczenie drugiego i trzeciego parametru wywołania ioctl.  
Używając przeglądarki kodu3 jądra NetBSD znajdź definicje operacji «DIOCEJECT», «KIOCTYPE» i «SIOCGIFCONF», a następnie wytłumacz co one robią.
</pre></div>

<h3
id="do-czego-służy-wywołanie-systemowe-ioctl2-zauważ-że-stosowane-jest-głównie-do-plików-urządzeń-znakowych-lub-blokowych.">Do
czego służy wywołanie systemowe ioctl(2)? Zauważ, że stosowane jest
głównie do plików urządzeń znakowych lub blokowych.</h3>
<p>No generalnie syscall stosowany do wielu miscellaneous rzeczy, APUE
podaje:</p>
<table>
<thead>
<tr class="header">
<th>Category</th>
<th>Prefix</th>
<th>Header</th>
<th>Constant Number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Disk Labels</td>
<td>DIOxxx</td>
<td><code>&lt;sys/disklabel.h&gt;</code></td>
<td>4</td>
</tr>
<tr class="even">
<td>File I/O</td>
<td>FIOxxx</td>
<td><code>&lt;sys/filio.h&gt;</code></td>
<td>14</td>
</tr>
<tr class="odd">
<td>Magnetic Tape I/O</td>
<td>MTIOxxx</td>
<td><code>&lt;sys/mtio.h&gt;</code></td>
<td>11</td>
</tr>
<tr class="even">
<td>Socket I/O</td>
<td>SIOxxx</td>
<td><code>&lt;sys/sockio.h&gt;</code></td>
<td>73</td>
</tr>
<tr class="odd">
<td>Terminal I/O</td>
<td>TIOxxx</td>
<td><code>&lt;sys/ttycom.h&gt;</code></td>
<td>43</td>
</tr>
</tbody>
</table>
<h3
id="na-podstawie-pliku-ioccom.h2-wyjaśnij-znaczenie-drugiego-i-trzeciego-parametru-wywołania-ioctl.">Na
podstawie pliku ioccom.h2 wyjaśnij znaczenie drugiego i trzeciego
parametru wywołania ioctl.</h3>
<div id="cb7" class="sourceCode">
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">ioctl</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fildes</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="cm">/* arg */</span><span class="p">)</span>
</pre></div>

</div>
<div id="cb8" class="sourceCode">
<div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">ioctl</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
</pre></div>

</div>
<div class="highlight"><pre><span></span>     37 /*
     38  * Ioctl&#39;s have the command encoded in the lower word, and the size of
     39  * any in or out parameters in the upper word.  The high 3 bits of the
     40  * upper word are used to encode the in/out status of the parameter.
     41  *
     42  *   31 29 28                     16 15            8 7             0
     43  *  +---------------------------------------------------------------+
     44  *  | I/O | Parameter Length        | Command Group | Command       |
     45  *  +---------------------------------------------------------------+
     46  */
</pre></div>

<div class="highlight"><pre><span></span> #define    _IOC(inout, group, num, len) \
     ((inout) | (((len) &amp; IOCPARM_MASK) &lt;&lt; IOCPARM_SHIFT) | \
     ((group) &lt;&lt; IOCGROUP_SHIFT) | (num))
 #define    _IO(g,n)    _IOC(IOC_VOID,  (g), (n), 0)
 #define    _IOR(g,n,t) _IOC(IOC_OUT,   (g), (n), sizeof(t))
 #define    _IOW(g,n,t) _IOC(IOC_IN,    (g), (n), sizeof(t))
 /* this should be _IORW, but stdio got there first */
 #define    _IOWR(g,n,t)    _IOC(IOC_INOUT, (g), (n), sizeof(t))
</pre></div>

<p>Trzeci parametr zależy od komendy, jest to czesto jakiś specyficzny
struct pointer.</p>
<h3
id="używając-przeglądarki-kodu3-jądra-netbsd-znajdź-definicje-operacji-dioceject-kioctype-i-siocgifconf-a-następnie-wytłumacz-co-one-robią.">Używając
przeglądarki kodu3 jądra NetBSD znajdź definicje operacji «DIOCEJECT»,
«KIOCTYPE» i «SIOCGIFCONF», a następnie wytłumacz co one robią.</h3>
<p>dkio.h 67 #define DIOCEJECT _IOW(‘d’, 112, int) /* eject removable
disk */</p>
<p>command for ejecting removable disk</p>
<p>110 #define KIOCTYPE _IOR(‘k’, 9, int) /* get keyboard type */
pobiera u_char kbd_id; w struct kbd_state</p>
<p>66 #define SIOCGIFCONF _IOWR(‘i’, 38, struct ifconf) /* get ifnet
list */ wywołuje ifconf, które “Return interface configuration of
system.”</p>
<div class="highlight"><pre><span></span>Records are added to the user buffer if they fit, and ifc_len is
adjusted to the length that was written.  Thus, the user is only
assured of getting the complete list if ifc_len on return is at
least sizeof(struct ifreq) less than it was on entry.
</pre></div>

<h2 id="zadanie-3">Zadanie 3</h2>
<div class="highlight"><pre><span></span>Zadanie 3. W systemach uniksowych katalog to ciąg bajtów reprezentujący listy rekordów dirent(3).
Na podstawie [3, rysunek 10-32] przedstaw reprezentację katalogu, a następnie wyjaśnij jak przebiegają operacje usuwania i dodawania pliku.  
W pierwszym przypadku rozważ scenariusz, w którym w reprezentacji katalogu za lub przed usuwanym wpisem istnieją nieużytki.  
W drugim, kiedy w pliku katalogu nie udaje się znaleźć wystarczająco dużo miejsca na przechowanie wpisu.  
Jądro leniwie wykonuje operację kompaktowania na katalogach – kiedy opłaca się ją zrobić?
</pre></div>

<h3
id="na-podstawie-3-rysunek-10-32-przedstaw-reprezentację-katalogu-a-następnie-wyjaśnij-jak-przebiegają-operacje-usuwania-i-dodawania-pliku.">Na
podstawie [3, rysunek 10-32] przedstaw reprezentację katalogu, a
następnie wyjaśnij jak przebiegają operacje usuwania i dodawania
pliku.</h3>
<p><img src="assets/10_32.png" /></p>
<p>dirent:</p>
<div id="cb13" class="sourceCode">
<div class="highlight"><pre><span></span><span class="kt">ino_t</span><span class="w">           </span><span class="n">d_fileno</span><span class="p">;</span>
<span class="kt">uint16_t</span><span class="w">        </span><span class="n">d_reclen</span><span class="p">;</span>
<span class="kt">uint16_t</span><span class="w">        </span><span class="n">d_namlen</span><span class="p">;</span>
<span class="kt">uint8_t</span><span class="w">         </span><span class="n">d_type</span><span class="p">;</span>
<span class="kt">char</span><span class="w">            </span><span class="n">d_name</span><span class="p">[</span><span class="n">MAXNAMLEN</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
</pre></div>

</div>
<p>Usuwanie:</p>
<div class="highlight"><pre><span></span>All the removeal has done is increase the size of the total entry field
for colossal, turning the former field for voluminous into padding for the first entry.
This padding can be used for a subsequent entry, of course
</pre></div>

<h3
id="w-pierwszym-przypadku-rozważ-scenariusz-w-którym-w-reprezentacji-katalogu-za-lub-przed-usuwanym-wpisem-istnieją-nieużytki">W
pierwszym przypadku rozważ scenariusz, w którym w reprezentacji katalogu
za lub przed usuwanym wpisem istnieją nieużytki</h3>
<p>Nieużytki zostają zkonsolidowane, tzn. d_reclen wpisu przed
nieuzytkami jest zwiekszany</p>
<h3
id="w-drugim-kiedy-w-pliku-katalogu-nie-udaje-się-znaleźć-wystarczająco-dużo-miejsca-na-przechowanie-wpisu.">W
drugim, kiedy w pliku katalogu nie udaje się znaleźć wystarczająco dużo
miejsca na przechowanie wpisu.</h3>
<p>Jest on dodawany na końcu</p>
<h3
id="jądro-leniwie-wykonuje-operację-kompaktowania-na-katalogach-kiedy-opłaca-się-ją-zrobić">Jądro
leniwie wykonuje operację kompaktowania na katalogach – kiedy opłaca się
ją zrobić?</h3>
<p>Kiedy jest dużo nieużytków</p>
<h2 id="zadanie-4">Zadanie 4</h2>
<div class="highlight"><pre><span></span>Zadanie 4. Korzystając z poleceń «stat» i «ls -lia» zaprezentuj jak jądro systemu operacyjnego trawersuje ścieżkę bezwzględną «/usr/bin/cc».  
Od jakiego numeru i-węzła algorytm zaczyna działanie?  
Skąd sterownik uniksowego systemu plików wie gdzie na dysku znajduje się i-ty bajt pliku?  
Próba utworzenia dowiązania do pliku «/proc/version» kończy się błędem «EXDEV».  
Czemu nie możemy tworzyć dowiązań do plików znajdujących się w obrębie innych zamontowanych systemów plików?
</pre></div>

<h3 id="od-jakiego-numeru-i-węzła-algorytm-zaczyna-działanie">Od jakiego
numeru i-węzła algorytm zaczyna działanie?</h3>
<p>/ ma numer 2</p>
<h3
id="skąd-sterownik-uniksowego-systemu-plików-wie-gdzie-na-dysku-znajduje-się-i-ty-bajt-pliku">Skąd
sterownik uniksowego systemu plików wie gdzie na dysku znajduje się i-ty
bajt pliku?</h3>
<p>Inode zawiera wskaźniki do bloków danych, są to wskaźniki
bezpośrednie, single indirect pointer, double indirect pointer i tripe
indirect pointer.<br />
No to żeby znaleźć numer bloku to będzie coś typu
ity_bajt/wielkosc_bloku.</p>
<h3
id="próba-utworzenia-dowiązania-do-pliku-procversion-kończy-się-błędem-exdev.-czemu-nie-możemy-tworzyć-dowiązań-do-plików-znajdujących-się-w-obrębie-innych-zamontowanych-systemów-plików">Próba
utworzenia dowiązania do pliku «/proc/version» kończy się błędem
«EXDEV». Czemu nie możemy tworzyć dowiązań do plików znajdujących się w
obrębie innych zamontowanych systemów plików?</h3>
<p>LPI p. 342</p>
<div class="highlight"><pre><span></span>Because directory entries (hard links) refer to files using just an i-node num-
ber, and i-node numbers are unique only within a file system, a hard link must
reside on the same file system as the file to which it refers.
</pre></div>

<h2 id="zadanie-5">Zadanie 5</h2>
<div class="highlight"><pre><span></span>Zadanie 5. Program «listdir» wypisuje zawartość katalogu w formacie przypominającym wyjście polecenia
«ls -l». Poniżej można znaleźć przykładowy wydruk, na którym widnieją odpowiednio: plik zwykły, dowiązanie
symboliczne, urządzenie znakowe, plik wykonywalny z bitem set-uid, jeden katalog z ustawionym bitem
set-gid i drugi z bitem sticky.
1 -rw-r--r-- 1 cahir cahir 2964 Fri Nov 15 14:36:59 2019 listdir.c
2 lrwxrwxrwx 1 cahir cahir 17 Mon Nov 4 11:14:49 2019 libcsapp -&gt; ../csapp/libcsapp
3 crw--w---- 1 cahir tty 4, 2 Tue Nov 12 08:42:33 2019 tty2
4 -rwsr-xr-x 1 root root 63736 Fri Jul 27 10:07:37 2018 passwd
5 drwxrwsr-x 10 root staff 4096 Mon Jan 9 13:49:40 2017 local
6 drwxrwxrwt 23 root root 12288 Fri Nov 15 16:01:16 2019 tmp
Uzupełnij kod programu według wskazówek zawartych w komentarzach w kodzie źródłowym. Należy użyć:
• fstatat(2) do przeczytania metadanych pliku,
• major(3) i minor(3) do zdekodowania numeru urządzenia,
• readlinkat(2) to przeczytania ścieżki zawartej w dowiązaniu symbolicznym.
Implementacja iterowania zawartości katalogu będzie wymagała zapoznania się ze strukturą «linux_dirent»
opisaną w podręczniku getdents(2). Wywołanie systemowe «getdents» nie jest eksportowane przez
bibliotekę standardową, zatem należało je wywołać pośrednio – zobacz plik «libcsapp/Getdents.c».
</pre></div>

<h2 id="zadanie-6">Zadanie 6</h2>
<div class="highlight"><pre><span></span>Zadanie 6. (Pomysłodawcą zadania jest Tomasz Wierzbicki.)
Program «primes» używa Sita Eratostenesa4 do obliczania liczb pierwszych z przedziału od 2 do 10000.
Proces główny tworzy dwóch potomków wykonujących procedurę «generator» i «filter_chain», spiętych rurą «gen_pipe». 
Pierwszy podproces wpisuje do rury kolejne liczby z zadanego przedziału.  
Drugi podproces tworzy łańcuch procesów filtrów, z których każdy jest spięty rurą ze swoim poprzednikiem.  
Procesy w łańcuchu powstają w wyniku obliczania kolejnych liczb pierwszych.  
Każdy nowy filtr najpierw wczytuje liczbę pierwszą p od poprzednika, po czym drukuje ją, a następnie kopiuje kolejne liczby z poprzednika do następnika za wyjątkiem liczb podzielnych przez p.  
Program musi poprawnie działać dla argumentu 10000 – w tym przypadku powinno zostać utworzonych 1229 + 2 podprocesów.

Uwaga! Rozwiązania, które nie zapewniają pochówku umarłym dzieciom lub nie dbają o zamykanie nieużywanych końców rur, są uważane za błędne. Będziemy to sprawdzać poleceniem «ps» i «lsof»
</pre></div>

<p><img src="assets/my_passion.png" /></p>
  </body>
</html>
